import * as React from 'react';
import * as ReactDOM from 'react-dom';
import * as PropTypes from 'prop-types';
import { FormWithConstraints, FieldFeedback as _FieldFeedback, FieldFeedbackType, FieldFeedbacks as _FieldFeedbacks, Async as _Async, FieldEvent } from 'react-form-with-constraints';
export class DisplayFields extends React.Component {
    constructor() {
        super(...arguments);
        this.reRender = () => {
            this.forceUpdate();
        };
    }
    componentWillMount() {
        const { form } = this.context;
        form.fieldsStore.addListener(FieldEvent.Added, this.reRender);
        form.fieldsStore.addListener(FieldEvent.Removed, this.reRender);
        form.addFieldDidValidateEventListener(this.reRender);
        form.addFieldDidResetEventListener(this.reRender);
    }
    componentWillUnmount() {
        const { form } = this.context;
        form.fieldsStore.removeListener(FieldEvent.Added, this.reRender);
        form.fieldsStore.removeListener(FieldEvent.Removed, this.reRender);
        form.removeFieldDidValidateEventListener(this.reRender);
        form.removeFieldDidResetEventListener(this.reRender);
    }
    render() {
        let str = stringifyWithUndefinedAndWithoutPropertyQuotes(this.context.form.fieldsStore.fields, 2);
        str = str.replace(/{\s+key: (.*),\s+type: (.*),\s+show: (.*)\s+}/g, '{ key: $1, type: $2, show: $3 }');
        return React.createElement("pre", { style: { fontSize: 'small' } },
            "Fields = ",
            str);
    }
}
DisplayFields.contextTypes = {
    form: PropTypes.instanceOf(FormWithConstraints).isRequired
};
const stringifyWithUndefinedAndWithoutPropertyQuotes = (obj, space) => {
    let str = JSON.stringify(obj, (_key, value) => value === undefined ? '__undefined__' : value, space);
    str = str.replace(/"__undefined__"/g, 'undefined');
    str = str.replace(/"([^"]+)":/g, '$1:');
    return str;
};
export { FormWithConstraints };
export class FieldFeedbacks extends _FieldFeedbacks {
    render() {
        const { for: fieldName, stop } = this.props;
        let attr = '';
        if (fieldName)
            attr += `for="${fieldName}" `;
        attr += `stop="${stop}"`;
        return (React.createElement(React.Fragment, null,
            React.createElement("li", null,
                "key=\"",
                this.key,
                "\" ",
                attr),
            React.createElement("ul", null, super.render())));
    }
}
export class FieldFeedback extends _FieldFeedback {
    getTextDecoration() {
        const { show } = this.state.validation;
        let textDecoration = '';
        switch (show) {
            case false:
                textDecoration = 'line-through';
                break;
            case undefined:
                textDecoration = 'line-through dotted';
                break;
        }
        return textDecoration;
    }
    render() {
        const { key, type } = this.state.validation;
        return (React.createElement("li", null,
            React.createElement("span", { style: { textDecoration: this.getTextDecoration() } },
                "key=\"",
                key,
                "\" type=\"",
                type,
                "\""),
            ' ',
            super.render()));
    }
    componentDidUpdate() {
        const el = ReactDOM.findDOMNode(this);
        const fieldFeedbackSpans = el.querySelectorAll('[data-feedback]');
        for (const fieldFeedbackSpan of fieldFeedbackSpans) {
            fieldFeedbackSpan.style.display = 'inline';
        }
        const li = el.closest('li.async');
        if (li !== null) {
            const async = li.querySelector('span[style]');
            async.style.textDecoration = this.getTextDecoration();
        }
        const { type } = this.state.validation;
        if (type === FieldFeedbackType.WhenValid) {
            const span = el.querySelector('span[style]');
            const whenValid = el.querySelector(`span.${this.props.classes.valid}`);
            span.style.textDecoration = whenValid !== null ? '' : 'line-through';
        }
    }
}
export class Async extends _Async {
    getTextDecoration() {
        return 'line-through dotted';
    }
    componentWillUpdate() {
        const el = ReactDOM.findDOMNode(this);
        const async = el.querySelector('span[style]');
        async.style.textDecoration = this.getTextDecoration();
    }
    render() {
        return (React.createElement("li", { className: "async" },
            React.createElement("span", { style: { textDecoration: this.getTextDecoration() } }, "Async"),
            React.createElement("ul", null, super.render())));
    }
}
